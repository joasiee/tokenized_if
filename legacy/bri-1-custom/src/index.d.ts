/// <reference types="node" />
import { IBaselineRPC, IBlockchainService, IRegistry, IVault } from "@baseline-protocol/api";
import { IMessagingService } from "@baseline-protocol/messaging";
import { Message as ProtocolMessage, Opcode } from "@baseline-protocol/types";
import { Application as Workgroup, Circuit, Invite, Vault as ProvideVault, Organization, Token, Key as VaultKey } from "@provide/types";
export declare class ParticipantStack {
    private baseline?;
    private baselineCircuit?;
    private baselineConfig?;
    private babyJubJub?;
    private hdwallet?;
    private initialized;
    private nats?;
    private natsBearerTokens;
    private natsConfig?;
    private protocolMessagesRx;
    private protocolMessagesTx;
    private protocolSubscriptions;
    private capabilities?;
    private contracts;
    private privacy?;
    private org?;
    private workgroup?;
    private workgroupCounterparties;
    private workgroupToken?;
    private workflowIdentifier?;
    private workflowRecords;
    constructor(baselineConfig: any, natsConfig: any);
    init(): Promise<void>;
    getBaselineCircuit(): Circuit | undefined;
    getBaselineConfig(): any | undefined;
    getBaselineService(): IBaselineRPC & IBlockchainService & IRegistry & IVault | undefined;
    getMessagingConfig(): any | undefined;
    getMessagingService(): IMessagingService | undefined;
    getNatsBearerTokens(): {
        [key: string]: any;
    };
    getOrganization(): any | undefined;
    getProtocolMessagesRx(): number;
    getProtocolMessagesTx(): number;
    getProtocolSubscriptions(): any[];
    getWorkflowIdentifier(): any;
    getWorkgroup(): any;
    getWorkgroupToken(): any;
    getWorkgroupContract(type: string): any;
    getWorkgroupContracts(): any[];
    getWorkgroupCounterparties(): string[];
    disconnect(): Promise<void>;
    private dispatchProtocolMessage;
    acceptWorkgroupInvite(inviteToken: string, contracts: any): Promise<void>;
    private marshalCircuitArg;
    generateProof(type: string, msg: any): Promise<any>;
    resolveMessagingEndpoint(addr: string): Promise<string>;
    resolveNatsBearerToken(addr: string): Promise<string>;
    sendProtocolMessage(recipient: string, opcode: Opcode, msg: any): Promise<any>;
    createWorkgroup(name: string): Promise<Workgroup>;
    private initWorkgroup;
    registerWorkgroupOrganization(): Promise<Organization>;
    setWorkgroup(workgroup: any, workgroupToken: any): Promise<void>;
    fetchWorkgroupOrganizations(): Promise<Organization[]>;
    createOrgToken(): Promise<Token>;
    createWorkgroupToken(): Promise<Token>;
    resolveOrganizationAddress(): Promise<string>;
    fetchOrganization(address: string): Promise<Organization>;
    requireCircuit(circuitId: string): Promise<Circuit>;
    fetchVaults(): Promise<ProvideVault[]>;
    createVaultKey(vaultId: string, spec: string, type?: string, usage?: string): Promise<VaultKey>;
    requireVault(token?: string): Promise<ProvideVault>;
    signMessage(vaultId: string, keyId: string, message: string): Promise<any>;
    fetchKeys(): Promise<any>;
    fetchSecret(vaultId: string, secretId: string): Promise<any>;
    deployBaselineCircuit(): Promise<Circuit>;
    deployWorkgroupContract(name: string, type: string, params: any, arvg?: any[]): Promise<any>;
    deployWorkgroupShieldContract(): Promise<any>;
    inviteWorkgroupParticipant(email: string): Promise<Invite>;
    private requireCapabilities;
    requireOrganization(address: string): Promise<Organization>;
    requireWorkgroup(): Promise<void>;
    requireWorkgroupContract(type: string): Promise<any>;
    resolveWorkgroupContract(type: string): Promise<any>;
    registerOrganization(name: string, messagingEndpoint: string): Promise<any>;
    startProtocolSubscriptions(): Promise<any>;
    protocolMessageFactory(opcode: Opcode, recipient: string, shield: string, identifier: string, payload: Buffer): Promise<ProtocolMessage>;
    vendNatsAuthorization(): Promise<string>;
}
//# sourceMappingURL=index.d.ts.map